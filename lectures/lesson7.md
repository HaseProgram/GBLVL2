# Лекция 7

## Вступление

Давайте представим такую ситуацию. Мы проектируем какое-то веб-приложение. У нас есть несколько компонентов, которые умеют взаимодействовать друг с другом. Все работает как часы, код прост и понятен.
 
Приложение растет, развивается, нам необходимо расширить его функционал. Появляются новые модули, появляются новые источники данных для этих модулей. Наступает момент, когда вы обнаруживаете, что из простого и понятного кода образовалось нечто – куча связных компонентов, обмен данными происходит непонятно как, появилось большое количество props в родительских компонентах, которые этим компонентам и не нужны вовсе, а нужны каким-то далеким дочерним модулям.
 
Одной из основных проблем такой архитектуры является ситуация, когда 2 или более компонента/модуля используют одни и те же данные, и меняют их. Особенно сложно в случаях, когда эти компоненты находятся в совершенно не связанных друг с другом частях нашего приложения:

<img alt="Компоненты в приложении" src="https://github.com/HaseProgram/GBLVL2/blob/main/lectures/images/vuex1.jpg" width="500" />

Если вспомнить наш прошлый урок, то мы знаем как во Vue можно передать данные от дочернего компонента родительскому и обратно: $emit и props. Если рассмотреть приведенную схему приложения, то, чтобы в нем передать информацию от крайнего левого компонента до крайнего правого, необходимо пройти весь путь через корень нашего приложения. Более того, сами данные должны храниться в этом корневом компоненте. Согласитесь – неудобно:

<img alt="Компоненты в приложении" src="https://github.com/HaseProgram/GBLVL2/blob/main/lectures/images/vuex2.jpg" width="500" />

Такое приложение становится очень трудно поддерживать, все чаще появляются баги, увеличивается время для внесения чего-то нового. Мы задаемся логичным вопросом: как можно облегчить себе жизнь? Радует, что мы не первые, кто столкнулся с этой проблемой, и существуют подходы, которые помогут организовать нам работу с данными в большом приложении.
Прежде всего, почему бы нам не вынести данные, которые используются в различных частях нашего приложения, в какое-то отдельное хранилище? Доступ к этому хранилищу получат только те компоненты, которым действительно нужны данные. Данным действием мы сможем избавиться от ненужной цепочки посредников между двумя компонентами, которые выделены на схеме выше.

Давайте попробуем представить, что нам нужно получить от такого хранилища? Какими свойствами оно должно обладать и какие проблемы должно уметь решать?
1) *Хранение данных.* Первое и самое главное, что должно уметь делать хранилище – хранить данные и предоставлять к этим данным прямой доступ.
2) *Изменение данных.* Данные не обязаны быть константными значениями, а значит в процессе жизни нашего приложения они могут обновляться. Хранилище должно поддерживать изменение этих данных.
3) *Актуальность состояния.* Если данными из хранилища пользуются несколько компонентов, то при изменении этих данных, все причастные компоненты должны быть оповещены об этом. Должны предоставляться актуальные значения.
С тем, как должно выглядеть хранилище в нашем приложении, и какими свойствами оно должно обладать мы определились. В реализации же нам поможет библиотека Vuex.

## VUEX Основы

Vuex – это официальная библиотека команды Vue для управления состоянием приложения.  Под состоянием здесь понимается набор данных нашего приложения. То есть это тот «источник истины», на основании которого рисуется представление (компоненты) приложения. Библиотека реализует концепции Flux-архитектуры. Что это за концепции? Давайте рассмотрим их на примере. Чтобы это сделать, установим и подключим Vuex в наше приложение.

### Vuex. Установка и настройка

Давайте изменим наше приложение таким образом, чтобы его данные хранились не в корневом компоненте, а в хранилище Vuex.
 
Первым делом, установим саму библиотеку:
``npm install vuex``
 
Дальше необходимо непосредственно подключить ее к нам в приложение. Давайте создадим файл ``store/index.js`` с таким контентом:
 
``store/index.js``
```JavaScript
import Vue from 'vue'
import Vuex from 'vuex'
 
Vue.use(Vuex)
 
export default new Vuex.Store({
 
})
```

Здесь мы сообщили Vue, что собираемся использовать Vuex в приложении, а также создали экземпляр глобального хранилища. Это созданное хранилище надо подключить в точке входа нашего приложения:

``index.js``
```JavaScript
mport Vue from 'vue'
import App from './App.vue'
 
// импортируем экземпляр созданного хранилища из листинга выше
import store from './store'
 
new Vue({
  el: 'main',
  template: '<App />',
  components: {
    App,
  },
  store, // подключаем хранилище к нашему приложению
})
```

Итак, из чего у нас состоит хранилище Vuex? Давайте перечислим все директивы, из которых оно состоит.
1) В центре любого Vuex приложения находится специальный контейнер, в котором хранится состояние нашего приложения. Описывается этот контейнер в специальной директиве *state*.
2) Данные, которые хранятся в нашем хранилище нельзя изменять напрямую из любой точки нашего приложения. Это одна из концепций архитектуры, которая лежит в основе Vuex. Чтобы дать нам возможность управлять нашим состоянием, Vuex предоставляет специальные функции, которые это могут делать. Такие функции описываются в директиве *mutations*.
3) Помимо хранения и изменения данных, нам необходимо уметь получать наше состояние в любом месте (в любом компоненте) нашего приложения. Учитывая эту необходимость, Vuex предоставляет нам специальные функции (можно провести аналогию с computed свойствами компонентов), которые описываются в директиве *getters*.
4) Помимо перечисленных директив, существует еще одна группа функций, которая описывается в директиве *actions*. Функции, содержащиеся в данной директиве могут содержать бизнес-логику, относящуюся управлению хранилищем (например, получение данных).

```JavaScript
import Vue from 'vue'
import Vuex from 'vuex'
 
Vue.use(Vuex)
 
export default new Vuex.Store({
    state: {},
    mutations: {},
    getters: {},
    actions: {},
})
```

Давайте рассмотрим каждую из директив более подробно.

#### state
Состояние нашего хранилища. Можно сказать, что именно объект state и является тем самым хранилищем, о котором мы постоянно говорим – это тот объект, который содержит в себе данные, с которыми мы будем работать.

Если мы обратимся к корневому компоненту App.vue, то найдем там объявление свойства данных paymentsList. Сейчас в нем и хранятся все записи о наших расходах. Перенесем эти данные в state. Для теста сразу заполним массив:

```JavaScript
state: {
  data: {},
  itemsOnPage: [],
}
```

#### mutations
Мутации – единственный способ, который позволяет нам изменить состояние нашего хранилища. Это их основная и единственная задача. Давайте реализуем функционал, который будет помещать в ``data`` и ``itemsOnPage`` данные. Все мутации будем описывать в специальном объекте mutations:

```JavaScript
mutations: {
  setData (state, payload) {
    state.data = payload.newData;
    state.itemsOnPage = Object.keys(payload.newData);
  },
},
```

Мутация является функцией, которая принимает в себя 2 аргумента:
- state - объект текущего состояния;
- payload – данные, передаваемые нашей мутации из компонента, совершающего мутацию. На основании этих данных хранилище будет менять свое состояние, переданное первым аргументом.

Давайте попробуем загрузить в наше хранилище начальные данные. Если мы обратимся к текущей реализации компонента App.vue, то увидим, что в хуке created у нас инициализируется свойство paymentsList из data этого компонента. Заменим данный код на вызов написанной мутации:

```JavaScript
created () {
  this.$store.commit('setData', {
    "1": { "id": 1, "name": "Shirt", "price": 150, "img": "/img/gb.png" },
    "2": { "id": 2, "name": "Socks", "price": 250, "img": "/img/gb.png" },
    "3": { "id": 3, "name": "Jacket", "price": 750, "img": "/img/gb.png" }
  })
}
```

После того, как мы подключили библиотеку Vuex в приложение, а также подключили созданный экземпляр, мы получили возможность обратиться к глобальному объекту состояния через свойство $store.

Для запуска мутации мы не можем напрямую обратиться к функции-обработчику. Для этого нам необходимо воспользоваться специальным методом commit, который принимает в себя два параметра: имя мутации, и данные, которые будут использоваться внутри мутации для изменения состояния хранилища.

Также, в нашем распоряжении имеется специальная функция mapMutations, входящая в состав библиотеки Vuex. С помощью этой функции можно проксировать мутации хранилища в методы компонента. Это значит, что мы можем обратиться к мутации setData напрямую, как к методу текущего компонента:
```JavaScript
import { mapMutations } from 'vuex'
 
export default {
  …
  methods: {
    ...mapMutations([
      'setData',
    ])
  },
  created () {
    this.setData(/* data */)
  }
}
```

``mapMutations`` принимает в себя перечисление названий тех мутаций, которые мы хотим использовать в нашем компоненте.

Отлично! Мы научились создавать хранилище и записывать в него данные. Но, как же мы можем воспользоваться этими данными внутри компонентов? Раз мы реализовали так называемые «сеттеры»-мутации, значит есть и «геттеры»? Совершенно верно!

#### getters

Vuex может предоставлять внешнему приложению доступ к своему состоянию (объекту state) напрямую. Чтобы обратиться к состоянию мы можем воспользоваться уже знакомым нам глобальным свойством $store, в котором имеются необходимые данные:
```JavaScript
this.$store.$state
```

Однако, обращаться к состоянию напрямую - плохая практика. Если у нас в приложении много обращений, и в какой-то момент возникла необходимость поменять структуру нашего объекта состояния, то придется менять обращения везде в коде, где они встречались. Было бы намного удобнее, если мы могли получать данные через какой-нибудь прокси. Такой прослойкой между компонентом и хранилищем выступают ``getters``.

``getters``, или как мы будем их называть «геттеры» – это по своей сути computed свойства нашего модуля vuex. Они позволяют нам получить данные, основанные на текущем состоянии (state).

Мы можем реализовать в геттерах те свойства, которые нам впоследствии могут понадобиться в компонентах нашего приложения. Если к этим свойствам будут обращаться несколько компонентов, то таким образом мы можем избавимся от дублирования кода.

```JavaScript
getters: {
  getData: state => state.data,
  getItemsOnPage: state => state.itemsOnPage,
  getFullPrice: state => {
    const keys = state.itemsOnPage;
    return keys.reduce((res, cur) => res + state.data[cur].price, 0);
  },
},
```

Можете обратить внимание, что геттер представляет из себя функцию, которая принимает один параметр state – текущее состояние. С помощью этого параметра мы обращаемся к нашему хранилищу, а именно к его данным. Как и computed свойства, геттер обязан возвращать результат через оператор return.

Как можем воспользоваться геттерами в компоненте?
```JavaScript
export default {
  …
  computed: {
    getData () {
      return this.$store.getters.getData
    }
  },
}
```

Также, аналогично с мутациями, в нашем распоряжении имеется специальная функция ``mapGetters``. С помощью этой функции можно проксировать геттеры хранилища в вычисляемые свойства компонента. Это значит, что мы можем обратиться к свойству ``getData`` напрямую, как к computed свойству текущего компонента:
```JavaScript
import { mapGetters } from 'vuex'
 
export default {
  computed: {
    ...mapGetters([
      'getData',
    ])
  },
}
```

Мы научились хранить, изменять и получать данные из нашего хранилища. Полученных знаний, казалось бы, вполне достаточно для полноценной работы с ``Vuex Store``. Однако, есть еще один аспект, который мы не рассмотрели. Перед обновлением данных в хранилище часто возникает потребность получить эти данные. Например, обращаясь за ними к бэкэнд серверу. Получать данные хочется в рамках хранилища, так как эта логика полностью укладывается в работу с данными. Где можно произвести такой запрос? Непосредственно в мутации этого сделать нельзя, так как мутация – синхронная операция и выполнение в ней любых асинхронных запросов запрещено.
На помощь нам придет еще одна директива, которую мы определяем в хранилище – ``actions``, действия.

#### actions
Actions – действия. Это специальные функции, которые содержат бизнес-логику приложения в рамках хранилища. Эти функции НЕ могут изменять состояние. То есть напрямую на данные они не влияют. Вызов действия является асинхронной операцией (то есть при вызове ``actions`` исполнение нашего кода не прекратится). Это удобно и зачастую именно в действиях выполняют какие-то запросы к серверу.
```JavaScript
actions: {
  requestData ({ commit, state }, page) {
    fetch(`/database/items${page}.json`)
      .then(res => {
        return res.json();
      })
      .then(res => {
        commit('setData', { newData: res });
      });
  }
},
```

Как мы видим, функция-action в качестве первого параметра получает объект контекста хранилища.
Контекст содержит в себе те же методы и свойства, что и сам экземпляр хранилища, поэтому мы можем вызвать context.commit для инициирования мутации, можем обратиться к геттерам через context.getters, а также обратиться напрямую к состоянию через context.state.
 
Вторым аргументом actions, по аналогии с мутациями получают «полезную нагрузку» - payload. Данные, полученные в payload, могут использоваться в качестве параметров к запросу на сервер, либо эти данные могут участвовать непосредственно в последующей мутации.



## Полезные ссылки
- [Документация](https://vuex.vuejs.org/ru/)
