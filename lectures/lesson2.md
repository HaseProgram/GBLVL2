# Лекция 2

Можно посмотреть пример в записи вебинара: [https://geekbrains.ru/lessons/117563](https://geekbrains.ru/lessons/117563)

- [OOP](https://github.com/HaseProgram/GBLVL2/blob/main/lectures/lesson2.md#OOP)
- [Инкапсуляция, наследование, полиморфизм](https://github.com/HaseProgram/GBLVL2/blob/main/lectures/lesson2.md#инкапсуляция-наследование-полиморфизм)
- [SET, GET](https://github.com/HaseProgram/GBLVL2/blob/main/lectures/lesson2.md#set-get)
- [Практика](https://github.com/HaseProgram/GBLVL2/blob/main/lectures/lesson2.md#практика)
- [Полезные ссылки](https://github.com/HaseProgram/GBLVL2/blob/main/lectures/lesson2.md#полезные-ссылки)

## OOP
Сегодня мы поговорим об объектно-ориентированном подходе в целом, а также о классах и объектах в JavaScript.
Для начала, что вообще такое объекты и классы? Здесь можно провести аналогию с реальным миром.

#### Объект

Все что вы видите, по сути является объектом.  
Человек (``Human``), кошка (``Cat``), камень (``Stone``), компьютер (``Computer``) – это все объекты.

Каждый объект имеет какие-то свойства.
Например, у человека есть имя, у кошки – длина хвоста, у камня – его цвет, у компьютера – производитель.
```
Human
  name
Cat
  tailLength
Stone
  color
Computer
  factory
```

Также, у каждого объекта есть какой-то набор действий, которые он может совершить.

Человек может ходить и разговаривать, кошка – может спать и есть, камень просто существовать, компьютер – много чего умеет (например, включаться и выключаться).

```
Human
  name
  walk()
  talk()
Cat
  tailLength
  eat()
  sleep()
Stone
  color
  exist()
Computer
  factory
  powerOn()
  powerOff()
```

Это можно перенести в мир программирования.
Здесь объекты – по сути те же материальные вещи, только в виртуальном пространстве.
И у этих объектов, как и в реальном мире есть свои свойства и набор действий (которые принято называть методами).

#### Класс

С объектами разобрались. Что же тогда такое классы?

Я думаю, что здесь можно провести аналогию с чертежом, схемой какого-то конкретного объекта.
По сути - так оно есть.  
Класс – это способ описать некоторую сущность, задать какие у этой сущности могут быть свойства, и какие операции может проводить эта сущность.

То, что я написал выше, можно уже назвать классами для какого-то абстрактного языка программирования.
Тут есть название класса (ex. ``Cat``), свойства (ex. ``name``) и методы (ex. ``powerOn``).
Давайте теперь уйдем от понятия «абстрактный язык программирования» и напишем класс в ES6 стандарте JavaScript.

Давайте возьмем, например сущность в виде кошки.
```JavaScript
class Cat {
}
```

По сути, это уже и есть простейший класс.
Сейчас в нем нет никаких свойств и операций, однако, мы уже можем сделать от него объект. Для этого надо написать:
```JavaScript
const myCat = new Cat()
console.log(myCat)
```
Как мы видим, объект действительно создался, ошибок никаких нет, но он пустой:
```bash
Object {
}
```

Давайте дадим кошке имя, и укажем, что она может есть и спать.
```JavaScript
class Cat {
  name = 'Alice'
  eat () {
    console.log('Cat gonna eat')
  }
  sleep () {
    console.log('Zzzzzz')
  }
}
const MyCat = new Cat()
console.log(MyCat)
MyCat.eat()
MyCat.sleep()
```

Мы видим, что объект теперь имеет имя, а также он может есть и храпеть:
```bash
Object {
  name: "Alice"
}
"Cat gonna eat"
"Zzzzzz"
```

Плохо то, что сколько бы кошек у нас не было, все они будут кошкой-Алисой.
Было бы здорово, чтобы при создании новой кошки мы могли присвоить ей любое имя.
Разумеется, это возможно, если мы зададим функцию-конструктор.
Эта функция будет вызываться при создании объекта, и в ней мы можем инициализировать свойства.

```JavaScript
class Cat {
  name = ''
  constructor (name) {
    this.name = name
  }
}
```

> Кстати, всегда, когда обращаетесь к методам или свойствам в рамках класса, необходимо использовать ключевое слово ``this``.

## Инкапсуляция, наследование, полиморфизм

Дальше, прежде чем продолжим, я хочу опять остановиться на парадигме ООП в целом, не касаясь JavaScript.

#### ИНКАПСУЛЯЦИЯ

По сути, это свойство позволяет пользователю (под пользователем здесь имеем в виду программиста, пишущего код) не задумываться о том, как устроена функция, объект, модуль (все что угодно) внутри, а взаимодействовать с ними только посредством предоставленного интерфейса. То есть, если мы говорим об объектах и классах и вернемся к нашей кошке, то нам не важно, как оно устроено внутри. Мы просто можем заставить ее есть вызвав ПУБЛИЧНЫЙ метод eat().

Почему я акцентировал внимание именно на ПУБЛИЧНЫЙ? Потому что в парадигме ООП существуют такие понятия как ``публичный``, ``приватный`` и ``защищенный`` метод (или свойство).

> Публичными методами и свойствами могут пользоваться как внутри класса (при реализации функционала), так и извне (программистами при написании кода).
> Приватными методами и свойствами можно пользоваться только внутри класса. Они служат для внутренней логики нашего модуля и не должны быть видимыми для окружения.
> Также есть такой тип как «защищенный», или protected. Свойства и методы, определенные с таким типом, не могут быть доступны снаружи, но могут быть доступны внутри класса и внутри класса-потомка.
Здесь мы постепенно подходим к понятию «наследования», так что давайте разберемся, что такое класс-потомок.

#### НАСЛЕДОВАНИЕ

Наследование – механизм, который позволяет описать новый класс, на основе существующего.
Обратимся опять к нашей кошке. Я думаю, что можно выделить отдельный класс – домашний питомец ``Pet``. Тогда ``Pet`` – будет классом-родителем для ``Cat``, а ``Cat``, в свою очередь, будет классом-потомком для ``Pet``.
В класс-родитель мы можем (и должны) поместить все те свойства и методы, которые могут быть присущи всем домашним питомцам, а не только кошке. Например. Имя – может быть как у кошки, так и у любимой рыбки. Способность есть и спать – также. Все это можем вынести в класс Pet.

```JavaScript
class Pet {
  name = ''
  constructor (name) {
    this.name = name
  }
  eat () {
    console.log('Creature gonna eat')
  }
  sleep () {
    console.log('Zzzzzz')
  }
}
```

Что же остается нашей кошке? Давайте сделаем ей метод «гулять» (например, рыбка у нас может плавать, но гулять – нет, так что нельзя данный метод вынести в родителя)

```JavaScript
class Cat extends Pet {
  walk () {
    console.log('Cat is walking now')
  }
}
```

Однако, мы опять потеряли нашу уникальность питомца, так как сейчас отсутствует функция-конструктор у класса, который мы будем создавать. Чтобы нам прокинуть параметры в функцию-конструктор родителя, необходимо вызывать в нашем конструкции функцию ``super()``. Более того, всегда, когда мы делаем в дочернем классе функцию конструктор, мы обязаны вызвать ``super()``, даже если там не передаются какие-то аргументы:

```JavaScript
class Cat extends Pet {
  constructor (name) {
    super(name)
  }
  walk () {
    console.log('Cat is walking now')
  }
}
```

#### ПОЛИМОРФИЗМ

И последнее, с чем нам осталось разобраться – странное слово полиморфизм.

Официально определение звучит так:
> Классы с одинаковой спецификацией могут иметь различную реализацию.
Что же это значит. Представим, что в нашем родительском классе ``Pet`` есть функционал “подать голос” - ``voice()``.

```JavaScript
class Pet {
  voice () {
    console.log('')
  }
}
```

Просто выводим пустоту в консоль, так как непонятно, о каком животном идет речь, и какие звуки оно производит.

Сделаем 2 дочерних класса: ``Cat`` и ``Dog``, в которых переопределим метод ``voice()``.

```JavaScript
class Cat extends Pet {
  voice () {
    console.log('Meow')
  }
}
class Dog extends Pet {
  voice () {
    console.log('Wow')
  }
}
```

Теперь представим, что мы завели себе и кошку, и собаку, и они все решили привлечь наше внимание:

```JavaScript
const myCat = new Cat()
const myDog = new Dog()
const myPets = [myCat, myDog]
myPets.forEach(pet => {
  pet.voice()
})
```

Собственно, это и есть полиморфизм: в массиве у нас объекты животных.
У них у всех есть метод «голос», но при запуске скрипта, этот методы будут вести себя по-разному. Попробуйте и убедителсь сами :)


## SET-GET

Последнее, что я хотел бы рассказать о классах на сегодня – про сеттеры и геттеры.

Собственно геттеры и сеттеры позволяют читать и записывать свойства в классах. Предположим, что у нас есть какое-то приватное свойство у нашего класса. В JavaScript вообще нет как таковых приватных свойств (в отличие от того же ``TypeScript``), но есть общепринятое правило, что свойства и методы, которые не следует использовать вне класса надо называть с нижнего подчеркивания. Итак, пусть данным свойством будет имя животного:
```JavaScript
class Pet {
  _name = ''
  constructor (name) {
    this._name = name
  }
}
```

Давайте установим публичный геттер для имени:

```JavaScript
class Pet {
  _name = ''
  constructor (name) {
    this._name = name
  }
  get name () {
    return this._name
  }
}
```

Теперь, если мы создадим объект, то можем получить его имя.

```JavaScript
// Попробуем изменить имя:
const pet = new Pet('A')
console.log(pet.name)
pet.name = 'B'
console.log(pet.name)
```
Если запустить скрипт, то мы увидим, что оно не изменилось, так как мы не указали для ``name`` сеттер. Таким образом можно сделать свойство только для чтения. Давайте сделаем так, чтобы можно было в эту переменную писать. Как вы уже догадались, я думаю, надо написать сеттер:

```JavaScript
class Pet {
  _name = ''
  constructor (name) {
    this._name = name
  }
  get name () {
    return this._name
  }
  
  set name (v) {
    this._name = v
  }
}
```

Теперь, если мы проделаем предыдущий пример, мы увидим, что имя изменилось.

## Практика

Думаю, что теперь можно перенести полученные знания уже непосредственно на нашу работу.
Прежде чем писать классы, нам надо посмотреть на наше приложение и выявить в нем составные части – максимально декомпозировать его.
Такое первоначальное проектирование архитектуры очень важно на начальном этапе, чтобы в последствии не пришлось переделывать.


На что можно разделить предлагаемую страницу интернет-магазина? Важно отметить, что любой элемент, который у нас повторяется, или может быть переиспользован, следует выносить в отдельный модуль (в нашем случае в отдельный класс).

Исходя из сказанного, явно, что главным объектом на странице является карточка товара. Дальше, если смотреть выше, то у нас есть сам список товаров (их компоновка).  Этот элемент хоть визуально может и не видим, но его явно надо определить как отдельную сущность (со своей логикой). Также у нас есть картина, форма поиска, обратной связи и прочие элементы со своей логикой, которые можно выделить в отдельные классы.

Давайте попробуем реализовать классы карточки и списка соответсвенно.

```JavaScript
class List {
  items = []

  constructor () {
    // Забираем массив со свойствами товаров, на основе которых будем создавать объекты товароы
    let goods = this.fetchGoods()

    // трансформируем наш массив со свойствами в массив с объектами
    goods = goods.map(cur => {
      return new GoodItem(cur)
    })

    // поштучно добавляем объекты в наш список
    // ссылка на статью про spread оператор ниже
    this.items.push(...goods)

    // запускаем рендер
    this.render()
  }

  /**
   * Заглушка - имитатор запроса на сервер
   * Возвращает свойства, на основании которых будут создаваться объекты
   **/ 
  fetchGoods () {
    return [
      { name: 'Shirt', price: 150 },
      { name: 'Socks', price: 15 },
      { name: 'Jacket', price: 50 },
      { name: 'Shoes', price: 1500 },
    ]
  }

  render () {
    // В this.items у нас хранятся объекты GoodItem
    // Проходимся по каждому такому объекту и вызываем у него метод рендера (каждая карточка товара рендерит сама себя)
    this.items.forEach(good => {
      good.render()
    })
  }
}
```

Теперь, можем реализовать класс карточки

```JavaScript
class GoodItem {
  name = ''
  price = 0

  // в аргументах применена деструктуризация (ссылка на статью ниже)
  constructor ({ name, price }) {
    this.name = name
    this.price = price
  }

  render () {
    // находим место куда рендерить
    const placeToRender = document.querySelector('.goods-list')
    if (placeToRender) {
      // создаем блок, в который помещаем информацию о товаре
      const block = document.createElement('div')
      block.innerHTML = `Товар: ${this.name} = ${this.price}`

      // помещаем созданный блок на страницу
      placeToRender.appendChild(block)
    }
  }
}
```

Все что нам остается - создать объект класса ``List``.Остальное он сделает сам.

```JavaScript
const ListInstance = new List()
```

## Полезные ссылки

- [Про Spread оператор](https://learn.javascript.ru/rest-parameters-spread-operator)
- [Про деструктуризацию](https://learn.javascript.ru/destructuring)

Пара хороших статей про this, call, bind, apply:  
- [Как работает this](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE-%D0%BE-%D1%82%D0%BE%D0%BC-%D0%BA%D0%B0%D0%BA-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-this-%D0%B2-javascript-a13b4b6ec9ac)
- [Различия в call, bind, apply](https://medium.com/@stasonmars/%D0%BF%D0%BE%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D0%BE-%D0%BE-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%D1%85-apply-call-%D0%B8-bind-%D0%BD%D0%B5%D0%BE%D0%B1%D1%85%D0%BE%D0%B4%D0%B8%D0%BC%D1%8B%D1%85-%D0%BA%D0%B0%D0%B6%D0%B4%D0%BE%D0%BC%D1%83-javascript-%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D1%83-ddd5f9b06290)

Если прочитаете, предлагаю попробовать написать свою реализацию функции bind:
```JavaScript
/**
 * @param {object} ctx - Переданное значение this
 * @param {function} func - Функция, к которой надо применить контекст
 */
const bind = (ctx, func) => {
  // ваша реализация (можно использовать call или apply)
}
```

Кто сможет - тому респет и уважение!
